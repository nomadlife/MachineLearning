0:00
지금까지 우리는 상당히 추상적 인 수준의 SVM에 대해 이야기 해 왔습니다. 이 비디오에서는 SVM을 실행하거나 사용하기 위해 실제로해야 할 일에 대해 이야기하고자합니다.
0:11
지원 벡터 머신 알고리즘은 특정 최적화 문제를 제기합니다. 그러나 이전 비디오에서 간략히 언급했듯이 매개 변수의 theta를 직접 해결하기 위해 자신의 소프트웨어를 작성하는 것은 권장하지 않습니다.
0:23
오늘날과 마찬가지로 우리 중 소수만이, 또는 본질적으로 거의 본질적으로 행렬을 뒤집거나 숫자의 제곱근을 취하는 등 코드를 직접 작성하지 않을 것입니다. 우리는 단지 라이브러리 함수를 호출하여이를 수행합니다. 같은 방법으로, SVM 최적화 문제를 해결하기위한 소프트웨어는 매우 복잡하며, 근본적으로 수년 동안 수치 최적화 연구를 수행해 온 연구자들이있었습니다. 그래서 좋은 소프트웨어 라이브러리와 좋은 소프트웨어 패키지를 만들어 낼 수 있습니다. 그런 다음 무언가를 직접 구현하는 것보다는 고도로 최적화 된 소프트웨어 라이브러리 중 하나를 사용하는 것이 좋습니다. 많은 소프트웨어 라이브러리가 있습니다. 가장 자주 사용하는 두 가지는 선형 SVM입니다. 그러나 이것을 배우기위한 훌륭한 소프트웨어 라이브러리가 많이 있습니다. 학습 알고리즘을 코딩하는 데 사용할 수있는 많은 주요 프로그래밍 언어에 연결할 수 있습니다 . 비록 당신이 자신의 SVM 최적화 소프트웨어를 작성해서는 안되지만,해야 할 일이 몇 가지 있습니다. 첫 번째는 매개 변수 C의 선택을 제안하는 것입니다. 우리는 이전 비디오에서이 편견 / 분산 속성에 대해 약간 이야기했습니다.
1:30
둘째, 사용할 커널 또는 유사성 기능을 선택해야합니다. 그러므로 커널을 사용하지 않기로 결정한다면 하나의 선택이 될 것입니다.
1:40
커널이 없다는 개념은 선형 커널이라고도합니다. 누군가가 말하길, 저는 선형 커널을 가진 SVM을 사용합니다. 즉, 커널을 사용하지 않고 SVM을 사용한다는 것을 의미하는 것이고 그것은 단지 theta transpose X를 사용하는 SVM 버전이었습니다. 1 theta 0 plus theta 1 X1 더하기 theta N, XN은 0보다 큽니다.
2:05
이 용어는 선형 커널입니다. SVM의 버전임을 알고있는 것처럼 생각할 수 있습니다.
2:10
표준 선형 분류자를 제공합니다.
2:13
따라서 어떤 문제에 대해서는 합리적인 선택이 될 것입니다. 선형과 같은 많은 소프트웨어 라이브러리가있을 것입니다. 커널을 사용하지 않고 SVM을 교육 할 수있는 소프트웨어 라이브러리의 한 예가 있습니다. 선형 커널이라고 불린다. 그래서, 왜 이것을하고 싶습니까? 많은 수의 기능이있는 경우 N이 크고 M의 학습 예제 수가 적 으면 X의 경우 X가 Rn, Rn +1 인 수많은 기능이 있음을 알 수 있습니다. 따라서 작은 훈련 세트를 사용하여 많은 양의 기능이 이미있는 경우에는 선형 의사 결정 경계에 맞추고 매우 복잡한 비선형 함수를 적합하게하려고하지 않을 수 있습니다. 충분한 데이터가 없기 때문일 수 있습니다. 그리고 매우 복잡한 함수에 맞추려고한다면 너무 많이 팔릴 위험이 있습니다.
3:01
매우 높은 차원의 기능 공간에서, 그러나 트레이닝 세트 샘플이 작은 경우. 따라서 이것은 커널을 사용하지 않기로 결정할 수도 있고, 선형 커널이라고 불리는 것을 사용할 수도 있습니다. 여러분이 만들 수있는 커널에 대한 두 번째 선택은이 가우스 커널이며 이것은 이전에 우리가 가지고 있었던 것입니다.
3:21
그리고 이렇게하면, 다른 선택은 바이어스 분산 트레이드 오프에 대해서 조금 이야기 할 때이 파라미터 sigma squared를 선택하는 것입니다
3시 30 분
어떻게하면, 시그마 제곱이 큰 경우, 바이어스가 더 낮고 분산 분류기가 낮아지는 경향이 있습니다. 시그마 제곱이 작 으면 더 높은 편차와 낮은 바이어스 분류자를 갖게됩니다.
3:43
언제 가우스 커널을 선택할 수 있습니까? 글쎄요, 만약 당신이 X의 생략을한다면, Rn을 의미하고, N이 작다면, 이상적으로, 당신도 알다시피,
3:55
n이 크면 오른쪽,
3:58
그래서 제가 예전에 그린 예와 같이 2 차원 트레이닝 세트라고 말하면됩니다. 그래서 n은 2와 같지만 꽤 큰 훈련 세트가 있습니다. 그래서, 꽤 많은 수의 훈련 예제를 작성한 다음,보다 복잡한 비선형 의사 결정 경계에 맞추기 위해 커널을 사용하고자 할 것입니다. 가우시안 커널은이를 수행하는 훌륭한 방법 일 것입니다. 비디오의 끝 부분에 대해 자세히 말씀 드리겠습니다. 선형 커널, 가우스 커널 등을 선택할 수있는시기에 대해 조금 더 설명 드리겠습니다.
4:27
하지만 구체적으로 가우스 커널을 사용하기로 결정했다면 다음과 같이하십시오.
4:35
사용하는 벡터 머신 소프트웨어 패키지를 지원하는 지에 따라 커널 기능을 구현하거나 유사 기능을 구현하도록 요청할 수 있습니다.
4:45
따라서 SVM의 옥타브 또는 MATLAB 구현을 사용하는 경우 커널의 특정 기능을 계산하는 함수를 제공해야 할 수도 있습니다. 그래서 이것은 i의 특정 값에 대해 실제로 f 개의 첨자 i를 계산합니다.
5시
f는 여기 하나의 실수이므로, 더 잘 작성된 f (i)를 옮겨야 할 것입니다.하지만 여러분이해야 할 일은이 입력을받는 커널 함수를 작성하는 것입니다.
5:10
트레이닝 예제 또는 테스트 예제를 사용하여 벡터 X를 입력하고 랜드 마크 중 하나를 입력하지만 여기서는 X1과 X2 만 사용했습니다. 랜드 마크는 실제로 트레이닝 예제이기도합니다. 그러나 당신이해야 할 일은이 입력을 받아들이는 소프트웨어, X1, X2를 작성하고 이들 사이의 유사성 기능을 계산하여 실수를 반환하는 것입니다.
5:36
그래서 어떤 지원 벡터 머신 패키지는 X1, X2라는 알고있는 입력을 받아서 실수를 반환하는이 커널 함수를 제공 할 것을 기대합니다.
5:45
그리고 나서 거기에서 가져올 것이고 자동으로 모든 피쳐를 생성 할 것이고, 그래서 당신이 쓴이 함수를 사용하여 X를 자동으로 받아 f1, f2, f (m)로 맵핑하고 모든 피쳐들과 열차를 생성 할 것입니다 거기에서 지원 벡터 기계. 그러나 때로는이 기능을 직접 제공해야합니다. 기타 Gaussian 커널을 사용하는 경우 일부 SVM 구현에는 Gaussian 커널과 다른 몇 가지 커널도 포함됩니다. Gaussian 커널이 가장 일반적인 커널 일 수 있기 때문입니다.
6:14
가우시안 및 선형 커널은 실제로 가장 인기있는 두 커널입니다. 단 하나의 구현 메모. 매우 다른 규모의 기능이있는 경우 중요합니다.
6:24
Gaussian 커널을 사용하기 전에 기능 확장을 수행 할 수 있습니다. 그 이유가 여기에 있습니다. 만약 당신이 X와 I 사이의 규범 컴퓨팅을 상상한다면, 바로 여기에서이 용어와 거기서의 분자 항이됩니다.
6:38
이것이 X와 l 사이의 규범입니다. 정말로, 말하자면, X를 빼는 벡터 V를 계산해 봅시다. 그리고 나서 벡터의 규범을 계산해 봅시다. 이것은 X의 차이입니다. 그래서 V의 규범은 실제로
6:53
V1 제곱 + V2 제곱 + 점 도트 점에 Vn 제곱을 더한 것과 같습니다. 여기 X가 Rn에 있거나 Rn에 1이 더하기 때문에 X0을 무시할 것입니다.
7:06
자, X가 Rn 인 것처럼 가정 해 봅니다. 왼쪽의 사각형은 이것이 올바른 것입니다. 그래서 이것은 그것과 동등합니다, 그렇죠?
7:17
다르게 쓰면, X1에서 l1 제곱, x2에서 l2 제곱, 플러스 점에 Xn-ln 제곱을 더한 값이됩니다.
7:29
이제 귀하의 기능
7:31
매우 다른 가치의 범위를 취하십시오. 예를 들어 주택에 대한 데이터가있는 경우 주택 예측을하십시오. 그리고 X가 수천 평방 피트 범위에 있다면 첫 번째 특징 인 X1. 하지만 두 번째 기능인 X2는 침실 수입니다. 그래서 이것이 1 ~ 5 개의 침실 범위에 있다면
7:57
X1에서 l1을 뺀 값이 커질 것입니다. 이것은 X2에서 l2가 훨씬 더 작아 질 것 인 반면에 천 제곱과 같을 수 있습니다. 그렇다면이 기간에,
8:08
그 거리는 거의 본질적으로 주택의 크기에 의해 지배 될 것입니다
8:14
욕실 수는 크게 무시 될 것입니다.
8:16
마찬가지로 기계 작동을 좋게하려면이 문제를 피하기 위해 미래의 스케일링을 수행하십시오.
8:23
그리고 그것은 SVM이 모든 다른 기능들에 대한 관심의 상당 부분을 제공한다는 것을 확신 할 것입니다, 그리고이 예제에서 집 크기는 여기에 큰 움직임을주었습니다.
8:34
여러분이 지원하는 벡터 머신을 시도 할 때, 사용하는 두 개의 가장 일반적인 커널은 커널이 없다는 것을 의미하는 선형 커널이거나 우리가 얘기 한 가우스 커널입니다. 그리고 당신이 생각해 낼 수있는 모든 유사성 기능이 유효한 커널이 아니라는 경고의 한 가지주의 사항 만 있습니다. 그리고 Gaussian 커널과 선형 커널 및 다른 커널을 사용할 때가 있습니다. 모두 기술적 조건을 만족시켜야합니다. 머서의 정리 (Mercer 's Theorem) 라 불리는 이유는 SVM의 지원 벡터 머신 알고리즘이나 구현이 영리한 수치 최적화 기법을 많이 가지고 있기 때문입니다. 매개 변수의 세타를 효율적으로 그리고 원래의 설계에서 구상하기 위해 Mercer 's Theorem이라는이 기술 조건을 만족하는 커널에만주의를 기울 이도록 결정했습니다. 그리고 그것은 모든 SVM 패키지, 모든 SVM 소프트웨어 패키지가 큰 클래스의 최적화를 사용하고 매개 변수 theta를 매우 빨리 얻을 수 있다는 것을 의미합니다.
9:39
그래서 대부분의 사람들은 선형 커널이나 가우스 커널을 사용하고 있습니다.하지만 머서의 정리를 만족시키는 몇 가지 다른 커널이 있습니다. 여러분이 아는 다른 커널을 개인적으로 사용하기는하지만, 매우 드물게, 거의, 전혀. 다른 커널을 언급 할 수 있습니다.
9:57
하나는 다항 커널입니다.
10:01
그리고 X와 l 사이의 유사성은 다음과 같이 정의됩니다. 많은 옵션이 있습니다. X transpose l squared를 사용할 수 있습니다. 여기 X와 I가 얼마나 비슷한 지에 대한 한 가지 방법이 있습니다. X와 I가 서로 매우 가깝다면 내부 제품은 커지는 경향이 있습니다.
10:20
그래서, 알다시피, 이것은 약간입니다.
10:23
비정상적인 커널. 그건 자주 사용되지 않지만
10:26
당신은 그것을 사용하는 사람들을 뛰어 넘을 수도 있습니다. 이것은 다항식 커널의 한 버전입니다. 또 다른 것은 X 전치 행렬입니다.
10:36
이것들은 모두 다항식 커널의 예입니다. X transpose l plus 1 cubed.
10:42
X는 아마도 1과 다른 숫자 일 것입니다. 5, 그리고 4의 힘으로
10:47
그래서 다항식 커널에는 실제로 두 개의 매개 변수가 있습니다. 하나는, 여기에 어떤 숫자를 더합니까? 0이 될 수 있습니다. 여기 저기에있는 다항식의 차수는 무엇인가에 더해 실제로 0을 더한 값입니다. 그래서 정도의 힘과 숫자. 그리고 더 일반적인 형태의 다항식 커널은 X transpose l이고, 어떤 상수를 더한 다음 X 1에서 어느 정도는 다항식 커널의 매개 변수입니다. 그래서 다항식 커널은 거의 항상 또는 보통 더 나빠집니다. 그리고 Gaussian 커널은 그렇게 많이 사용하지는 않지만, 여러분이 실행할 수있는 것입니다. 일반적으로 X와 l이 모두 부정적이지 않은 데이터에만 사용되므로 이러한 내부 제품이 결코 부정적이지 않음을 보증합니다.
11:37
그리고 이것은 X와 I가 서로 매우 흡사하다는 직관을 포착합니다. 그러면 아마도 그들 사이의 상호 제품이 커질 것입니다. 그들은 다른 속성도 가지고 있지만 사람들은 그것을 많이 사용하지 않는 경향이 있습니다.
11:49
그리고 나서, 당신이하고있는 일에 따라 다른 종류의 것이 있습니다.
11:52
밀교적인 커널도 있습니다. 아시다시피, 문자열 커널이 있습니다. 이것은 입력 데이터가 텍스트 문자열 또는 다른 유형의 문자열 인 경우에 사용됩니다. 카이 제곱 커널, 히스토그램 교차점 커널 등과 같은 것들이 있습니다. 서로 다른 객체 간의 유사성을 측정하는 데 사용할 수있는 더 밀교적인 커널이 있습니다. 그래서 예를 들어, 여러분이 어떤 종류의 텍스트 분류 문제를하려고한다면, 입력 x가 문자열 일 때 문자열 커널을 사용하여 두 문자열 사이의 유사점을 찾으려고합니다. 그러나 저는 개인적으로 매우 드물게 끝납니다. , 전혀,이 더 밀교적인 커널을 사용한다. 내 카이 제곱 커널을 사용했을 수도 있고, 내 인생과 히스토그램 커널에 한번있을 수도 있고, 제 인생에서 한두 번있을 수도 있습니다. 나는 실제로 문자열 커널을 사용하지 않았다. 하지만 다른 애플리케이션에서이 작업을 실행 한 경우에 대비하십시오. 있잖아, 만약
12:42
우리는 빠른 웹 검색을 수행합니다. 빠른 Google 검색 또는 빠른 Bing 검색을 수행하면 커널이라는 정의를 찾아야합니다. 그래서
12:51
이 비디오에서 제가 이야기하고 싶은 마지막 두 가지 세부 사항 만 있습니다. 하나는 여러 분류로 분류됩니다. 따라서 4 개의 클래스가 있거나 더 일반적으로 3 개의 클래스가 여러 클래스 사이에 적절한 결정 경계를 출력합니다. 대부분의 SVM, 많은 SVM 패키지에는 이미 멀티 클래스 분류 기능이 내장되어 있습니다. 그래서 당신이 그런 식으로 패턴을 사용한다면, 당신은 그 기능을 모두 사용하기 만하면됩니다. 그렇지 않은 경우,이를 수행하는 한 가지 방법은 로지스틱 회귀를 개발할 때 우리가 이야기했던 모든 방법 대 모든 방법을 사용하는 것입니다. 그래서 당신이하는 것은 당신이 k 클래스를 가지고 있다면 kSVM의 거래입니다. 하나는 클래스를 나머지 클래스와 구별하는 것입니다. 그리고 이것은 k 매개 변수 벡터를 줄 것이므로 이것은 당신에게 줄 것입니다. 클래스 y를 다른 클래스와 모두 구별하려고하는 theta 1은 두 번째 매개 변수 인 vector theta 2를 얻습니다. 이는 y가 양수 클래스로 2 일 때 얻을 수있는 것입니다. 모든 다른 것들은 음의 클래스로, 그리고 마지막으로 클래스 키를 다른 것과 구별하기위한 매개 변수 벡터 인 theta vector까지의 매개 변수 벡터까지 그리고 마지막으로 이것은 우리가 가지고있는 모든 방법 대 정확히 같은 것입니다 로지스틱 회귀. 우리는 가장 큰 theta transpose X를 가진 클래스 i를 예측할 것입니다. 그래서 다중 클래스 분류를 지정합시다. 보다 일반적인 경우에는 사용하는 소프트웨어 패키지가 무엇이든간에 이미 여러 클래스 분류 기능에 내장 된 합리적인 기회가 있으므로이 결과에 대해 걱정할 필요가 없습니다. 마지막으로, 우리는 로지스틱 회귀 (logistic regression)로 시작하여 비용 함수를 조금 수정하는 지원 벡터 머신을 개발했습니다. 이 비디오에서 우리가하고 싶은 마지막 일은 조금만 이야기하면됩니다. 이 두 알고리즘 중 하나를 사용할 경우, n이 피처의 수이고 m이 학습 예제의 수라고 가정 해 봅시다.
14:43
그렇다면 언제 다른 알고리즘을 사용해야합니까?
14:47
음, n이 훈련 세트 크기에 비해 더 큰 경우, 예를 들어,
14:52
여러 가지 기능을 가진 비즈니스를 취하는 경우이 기능은 m보다 훨씬 큽니다. 예를 들어 텍스트 분류 문제가있는 경우, 내가 아는 곳에서 기능 벡터의 크기를 모를 수 있습니다. , 만.
15:05
그리고 당신의 훈련 세트 크기가 아마 10 일 것입니다. 어쩌면 최대 1000입니다. 그래서 스팸 분류 문제를 상상해보십시오. 10,000 개의 단어에 해당하는 10,000 개의 기능이있는 전자 메일 스팸이 있지만 10 개의 교육 예제가있을 수 있습니다. 또는 최대 1,000 개의 사례가있을 수 있습니다.
15:22
따라서 n이 m보다 크다면, 보통 내가 할 일은 로지스틱 회귀를 사용하거나 커널없이 m으로 사용하거나 선형 커널로 ​​사용하는 것입니다. 왜냐하면, 작은 훈련 세트를 가진 많은 기능을 가지고 있다면, 선형 함수는 아마 잘 할 것이고, 당신은 매우 복잡한 비선형 함수에 적합 할만큼 충분한 데이터를 가지고 있지 않기 때문입니다. 이제 n이 작고 m이 중간 인 경우 n은 1 ~ 1000 사이의 임의의 위치에 있으며 1은 매우 작습니다. 그러나 어쩌면 최대 1000 개의 기능과 훈련 예제 수가 10 개에서 10 개 사이라면 아마도 10 개에서 최대 10,000 개까지의 예제를 알고있을 것입니다. 어쩌면 최대 50,000 가지의 예를들 수 있습니다. 만약 m이 10000이나 10000처럼 꽤 클 경우. 권리? 그래서 m이 중간 크기라면 선형 커널을 가진 SVM이 잘 작동합니다. 우리는 일찍이 이것에 대해서도 이야기했습니다. 구체적인 예를 들어, 2 차원 트레이닝 세트를 가지고 있다면 이것이 될 것입니다. 그래서, n이 2라면, 꽤 많은 수의 훈련 예제를 그릴 수 있습니다.
16:24
따라서 Gaussian 커널은 양수와 음수의 클래스를 구분하는 훌륭한 일을합니다.
16:29
관심의 대상인 1/3 설정은 n이 작지만 m이 클 경우입니다. 그래서 n이 너라면, 아마 1에서 1000 일 정도 더 커질 수도있다. 그러나 m이 어쩌면 50,000에서 수백만으로 커질 수 있습니다.
16:47
그래서, 50,000, 100,000,000,000 조.
16:51
매우 큰 훈련 세트 크기가 있습니다.
16:55
따라서이 경우 가우스 커널의 SVM은 다소 느리게 실행됩니다. 오늘날의 SVM 패키지는 Gaussian Kernel을 사용하는 경우 다소 어려움을 겪습니다. 만약 당신이 알고 있다면, 아마 50 만명은 괜찮 겠지 만 엄청난 가치의 m을 가진 백만 가지 훈련 예제가 있을지도 모르겠다. 오늘날의 SVM 패키지는 매우 훌륭하지만 Gaussian Kernel을 사용할 때 크기가 엄청나게 커질 때 조금 어려움을 겪을 수 있습니다.
17:22
그래서이 경우, 보통 내가 수동으로 만들어서 더 많은 기능을 만든 다음 커널없이 로지스틱 회귀 또는 SVM을 사용하려고합니다.
17:33
그리고이 슬라이드를 보면 커널이없는 로지스틱 회귀 또는 SVM을 볼 수 있습니다. 이 두 곳에서 나는 서로를 짝 지어 ​​주었다. 그 이유는 로지스틱 회귀와 커널이없는 SVM은 정말 비슷한 알고리즘이며, 커널이없는 로지스틱 회귀 또는 SVM은 보통 비슷한 일을하지만 비슷한 성능을 제공합니다. 구현 세부 사항 중 하나가 다른 것보다 효율적일 수 있습니다. 그러나 이러한 알고리즘 중 하나가 적용되는 경우, 로지스틱 회귀 (logistic regression)는 커널이없는 SVM이고, 다른 하나는 잘 작동 할 가능성이 높습니다. 그러나 SVM의 힘과 함께 복잡한 커널을 사용하여 복잡한 비선형 함수를 학습하는 경우도 있습니다. 그리고이 정권은 아마 당신이 최대 10,000 개의 사례를 가지고있을 때, 아마도 최대 5 만개의 사례를 가지고있을 때 알 수 있습니다. 그리고 기능의 수,
18:26
이것은 상당히 크다. 이것은 매우 일반적인 체제이며 아마도 커널 커널이있는 지원 벡터 머신이 빛날 것입니다. 당신은 로지스틱 회귀를 필요로 할 일을 훨씬 더 어렵게 할 수 있습니다. 그리고 마지막으로, 신경 네트워크는 어디에 들어 맞습니까? 이러한 모든 문제들에 대해서,이 모든 다른 체제들에 대해서, 잘 설계된 신경 회로망은 잘 작동 할 것입니다.
18:50
한 가지 단점, 또는 때때로 신경 네트워크를 사용하지 않는 한 가지 이유는 이러한 문제 중 일부의 경우 신경 네트워크가 느리게 훈련 될 수 있다는 것입니다. 그러나 SVM 구현 패키지가 아주 좋다면 신경망보다 훨씬 빠르게 실행될 수 있습니다.
19:05
그리고 이전에이를 보여주지는 않았지만 SVM의 최적화 문제는 볼록합니다.
19:12
최적화 문제가 있으므로 좋은 SVM 최적화 소프트웨어 패키지는 항상 전역 최소값 또는 그와 가까운 값을 찾습니다. 따라서 SVM의 경우 로컬 최적 값에 대해 걱정할 필요가 없습니다.
19:25
실제로 로컬 최적화는 신경망에 큰 문제는 아니지만 모두 해결되므로 SVM을 사용하는 경우 걱정할 필요가 없습니다.
19:33
그리고 문제에 따라 신경 네트워크가 느릴 수도 있습니다. 특히 SVM보다 정권의 경우 더 느립니다. 그들이 여기에 제시 한 가이드 라인이 다소 모호한 것처럼 보이고 몇 가지 문제를보고 있다면,
19:46
가이드 라인이 다소 모호합니다. 아직 완전히 확신 할 수는 없지만, 실제로이 알고리즘이나 알고리즘을 사용해야 만합니다. 내가 기계 학습 문제에 직면했을 때, 때때로 그 알고리즘이 사용하기 가장 좋은 알고리즘인지는 분명하지 않지만 이전 비디오에서 보았 듯이 알고리즘은 중요하지만 실제로는 더 중요한 것은 무엇인가? 많은 데이터가 얼마나 많은가? 얼마나 능숙합니까? 오류 분석 및 학습 알고리즘 디버깅, 새로운 기능 설계 방법 및 학습 알고리즘 등을 제공하기위한 다른 기능 파악에 얼마나 능숙하십니까? 그리고 종종 이러한 것들은 당신이 로지스틱 회귀 또는 SVM을 사용하는 것보다 더 중요 할 것입니다. 그러나 SVM은 여전히 ​​가장 강력한 학습 알고리즘 중 하나로 널리 인식되고 있으며 복잡한 비선형 함수를 학습하는 데 효과적인 방법이있는 경우에이 체계가 있습니다. 그래서 저는 사실 로지스틱 회귀, 신경망, SVM과 함께 학습 알고리즘의 속도를 높이기 위해 당신이 알고있는 예술 상태를 구축하기에 매우 유리하다고 생각합니다. 응용 프로그램을위한 넓은 지역의 기계 학습 시스템입니다. 귀하의 무기고에 가지고있는 또 다른 매우 강력한 도구. 실리콘 밸리의 모든 곳이나 산업계 및 학계에서 사용되어 하나의 고성능 기계 학습 시스템을 구축합니다.
